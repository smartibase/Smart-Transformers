# coding=utf-8
# Copyright 2024 the HuggingFace Inc. team. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import argparse
import glob
import importlib
import os
import re
from collections import defaultdict, deque
from typing import Dict, List, Optional, Set

import libcst as cst
from check_copies import run_ruff
from create_dependency_mapping import find_priority_list
from libcst import ClassDef, CSTTransformer, CSTVisitor
from libcst import matchers as m
from libcst.metadata import MetadataWrapper, ParentNodeProvider, PositionProvider, ScopeProvider

from transformers import logging
from transformers.models.auto.configuration_auto import CONFIG_MAPPING_NAMES


logger = logging.get_logger(__name__)


# This is used to avoid overwriting these top-level assignments even if they are in the dependency graph. Otherwise, the
# value from the dependency is used, then mapped to current name convention, resulting in wrong value.
# The corresponding mapped values are used to define the file targets for the assignment.
ASSIGNMENTS_TO_KEEP = {
    "_CHECKPOINT_FOR_DOC": ["modeling"],
    "logger": ["modeling", "configuration", "tokenization", "processing", "image_processing", "feature_extractor"],
}

AUTO_GENERATED_MESSAGE = """#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨
#           This file was automatically generated from {relative_path}.
#               Do NOT edit this file manually as any edits will be overwritten by the generation of
#             the file from the modular. If any change should be done, please apply the change to the
#                          {short_name} file directly. One of our CI enforces this.
#                ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨ðŸš¨
"""


def get_module_source_from_name(module_name: str) -> str:
    # Extract the source code from the module name
    spec = importlib.util.find_spec(module_name)
    if spec is None or spec.origin is None:
        return f"Module {module_name} not found"

    with open(spec.origin, "r") as file:
        source_code = file.read()
    return source_code


def find_all_dependencies(
    dependency_mapping: Dict[str, set],
    start_entity: str | None = None,
    initial_dependencies: set | None = None,
    initial_checked_dependencies: set | None = None,
    return_parent: bool = False,
) -> list | set:
    """Return all the dependencies of the given `start_entity` or `initial_dependencies`. This is basically some kind of
    BFS traversal algorithm. It can either start from `start_entity`, or `initial_dependencies`.

    Args:
        dependency_mapping (`Dict[str, set]`):
            A mapping from entities (usually function names), to immediate dependencies. That is, for function names,
            a mapping {"foo": {"bar", "test"}} would indicate that functions `bar` and `test` are immediately called
            in `foo`'s definition.
        start_entity (str | None, *optional*):
            A key of `dependency_mapping`, indicating from which entity to start the search.
        initial_dependencies (set | None, *optional*):
            If `start_entity` is not provided, this can be used as an alternative. In this case, `initial_dependencies`
            the search will continue from all the entities in `initial_dependencies`, if they are in `dependency_mapping`.
        initial_checked_dependencies (set | None, *optional*):
            If provided, entities already present in `initial_checked_dependencies` will not be part of the returned dependencies.
        return_parent (bool, *optional*):
            If `True`, will return a list consisting of tuples (dependency, parent) instead of a simple set of dependencies. Note
            that the order of the items in the list reflects the traversal order. Thus, no parent can ever appear before childs.
    Returns:
        A set of all the dependencies, or a list containing parents as well if `return_parent=True`.

    Example:
    Given the following structure in the `modular_xxx.py` file:
    ```
    def foo1():
        pass

    def foo2():
        pass

    def bar():
        foo1()

    def foobar():
        bar()
        foo2()

    class MyLayer(SomeOtherModelLayer):
        def forward(...):
            foobar()
    ```
    and the `dependency_mapping` created when visiting the `modular_xxx.py` file, we get:
    ```
    dependency_mapping = {'bar': {'foo1'}, 'foobar': {'bar', 'foo2'}}
    find_all_dependencies(dependency_mapping, start_entity='foobar', return_parent=True)
    >>> [('bar', 'foobar'), ('foo2', 'foobar'), ('foo1', 'bar')]
    ```
    That is, all the functions needed (and potentially their immediate parent) so that the function to be added
    in MyLayer (`foobar`) can work correctly.
    """
    if initial_dependencies is None and start_entity is not None:
        initial_dependencies = dependency_mapping[start_entity]
    if initial_checked_dependencies is None:
        initial_checked_dependencies = set()

    dependency_queue = deque(initial_dependencies)
    all_dependencies = set()
    all_dependencies_with_parent = []
    checked_dependencies = set(initial_checked_dependencies)
    parents = {initial_dep: start_entity for initial_dep in initial_dependencies}
    while len(dependency_queue) > 0:
        # Pick element to visit
        current = dependency_queue.popleft()
        if current not in checked_dependencies:
            # Add the dependencies
            all_dependencies.add(current)
            all_dependencies_with_parent += [(current, parents[current])]
            if current in dependency_mapping.keys():
                # Update dependency queue
                dependency_queue.extend(dependency_mapping[current])
                parents.update({dep: current for dep in dependency_mapping[current]})
            # add visited node to the list
            checked_dependencies.add(current)

    if not return_parent:
        return all_dependencies
    # no child can ever appear before its parent thanks to the queue (needed to add them at the correct location in the body later)
    return all_dependencies_with_parent


class ClassDependenciesFinder(CSTVisitor):
    """A visitor which analyzes classes to get their dependencies. If `global_names` is passed, only dependencies
    present in the `global_names` will be added.
    This class is used through the 3 convenient class methods allowing to get the dependencies of a given class node.
    The `ClassFinder` uses it to get dependencies of classes.
    """

    def __init__(self, class_name: str, global_names: set | None):
        super().__init__()
        self.class_name = class_name
        self.dependencies = set()
        self.global_names = global_names

    def visit_Name(self, node):
        if node.value != self.class_name and node.value not in ASSIGNMENTS_TO_KEEP.keys():
            # In this case, adds the dependencies only if they match one of the global names
            if self.global_names is not None and node.value in self.global_names:
                self.dependencies.add(node.value)
            # In this case, adds all Call nodes
            elif self.global_names is None:
                self.dependencies.add(node.value)

    @classmethod
    def dependencies_for_node(cls, node: cst.ClassDef, global_names: set) -> set:
        """Create dependencies for a node in the `ClassFinder`."""
        temp_module = cst.Module(body=[node])
        visitor = cls(node.name.value, global_names)
        temp_module.visit(visitor)
        return visitor.dependencies

    @classmethod
    def dependencies_for_new_node(cls, updated_node: cst.ClassDef, class_finder: "ClassFinder") -> set:
        """Create dependencies for a node that was changed by `replace_call_to_super` and has a parent super-class."""
        temp_module = cst.Module(body=[updated_node])
        visitor = cls(updated_node.name.value, set(class_finder.global_nodes.keys()))
        temp_module.visit(visitor)
        return class_finder.augment_dependencies_with_functions(visitor.dependencies)

    @classmethod
    def dependencies_for_new_node_without_parents(cls, updated_node: cst.ClassDef) -> set:
        """Create dependencies for a node without super-class parent."""
        temp_module = cst.Module(body=[updated_node])
        visitor = cls(updated_node.name.value, None)
        temp_module.visit(visitor)
        return visitor.dependencies


class ClassFinder(CSTVisitor):
    """A visitor class which analyses a module, creating a mapping of dependencies for classes and functions.
    The `class_dependency_mapping` created contains 1st-level classes and assignments dependencies, as well
    as all (recursively) functions dependencies.
    The `function_call_recursive_dependecy_mapping` created contains all function definitions, and all their (recursively)
    dependencies.

    For example if the visited code has
    ```python3
    def init_value(): return 1

    class LlamaModel(PreTrainedModel):
        def __init__(self):
            super().__init__(self)
            self.value = init_value()
    ```
    then the `class_dependency_mapping` should be: `{"LlamaModel": {"PreTrainedModel", "init_value"}}

    The dependency mapping is updated via the `ClassDependenciesFinder`, then augmented with `augment_dependencies_with_functions`
    to get all functions dependencies.

    Optionally, if `only_for_function_mapping` is True, this class will only create the `function_call_recursive_dependecy_mapping`
    for the given Module. This is useful for performance.
    """

    METADATA_DEPENDENCIES = (ParentNodeProvider, ScopeProvider, PositionProvider)

    def __init__(self, python_module: cst.Module, only_for_function_mapping: bool = False):
        # fmt: off
        self.python_module: cst.Module = python_module  # original cst.Module being visited
        self.classes: Dict[str, cst.ClassDef] = {}      # mapping from class names to Nodes
        self.imports = {}                               # stores all import statements
        self.function_def = {}                          # mapping of global scope function names to Nodes
        self.assignments = {}                           # mapping of global assignments names to Nodes
        self.class_dependency_mapping = {}              # mapping of function name to immediate dependencies
        self.current_function = None
        self.function_call_dependency_mapping = defaultdict(set)
        # fmt: on
        # This is for performance when we only want to get the functions mapping (using the class finder without rename)
        self.only_for_function_mapping = only_for_function_mapping

    def visit_SimpleStatementLine(self, node):
        """
        Global Assigns like `GEMMA_INPUT_DOCSTRING = 'THIS IS THE INPUT' and all import statements
        are extracted and saved in their corresponding dict. They are then used when updating dependency mappings.
        """
        # If we are not only creating the function mapping
        if not self.only_for_function_mapping:
            if m.matches(node, m.SimpleStatementLine(body=[m.Assign()])) and m.matches(
                self.get_metadata(cst.metadata.ParentNodeProvider, node), m.Module()
            ):
                left_hand_side = node.body[0].targets[0].target
                if hasattr(left_hand_side, "value"):
                    self.assignments[left_hand_side.value] = node
                else:
                    for idx, target in enumerate(list(left_hand_side.elements)):
                        self.assignments[target.value.value] = node.body[0].value.elements[idx].value
            if m.matches(node, m.SimpleStatementLine(body=[m.Import() | m.ImportFrom()])):
                self.imports[node.body[0].names] = node

    def visit_FunctionDef(self, node):
        parent_node = self.get_metadata(cst.metadata.ParentNodeProvider, node)
        if m.matches(parent_node, m.Module()):
            self.current_function = node.name.value
            self.function_def[node.name.value] = node

    def leave_FunctionDef(self, node):
        parent_node = self.get_metadata(cst.metadata.ParentNodeProvider, node)
        if m.matches(parent_node, m.Module()):
            self.current_function = None

    def leave_If(self, node):
        # If we are not only creating the function mapping
        if not self.only_for_function_mapping:
            for stmt in node.body.body:
                if m.matches(stmt, m.SimpleStatementLine(body=[m.ImportFrom() | m.Import()])):
                    self.imports[stmt.body[0].names] = node

    def visit_ClassDef(self, node: ClassDef) -> None:
        """Record class nodes to create their dependencies at the end."""
        # If we are not only creating the function mapping
        if not self.only_for_function_mapping:
            self.classes[node.name.value] = node

    def visit_Call(self, node: cst.Call):
        """This is used to create a mapping from top-level functions to functions called inside them.
        Important note: we only rely on direct Call to the functions here, not indirect mentions (such as assigning a variable with the function,
        add calling the variable later). This should be enough as the `modular_xxx` and `modeling_xxx` structures should be as simple as possible.
        """
        if self.current_function is not None:
            # Simple function calls such as foo()
            if m.matches(node.func, m.Name()):
                self.function_call_dependency_mapping[self.current_function].add(node.func.value)

    def leave_Module(self, node):
        """When leaving the module, we finally create the `function_call_recursive_dependency_mapping`, then we
        compute the dependencies for all recorded classes based on all the nodes we visited.
        We also store the position of each global scoped node to allow sorting the dependencies based on their
        position in the code later. We use the PositionProvider metadata wrapper for this.
        """
        # Create a global mapping of recursive dependencies for functions
        self.function_call_recursive_dependency_mapping = {}
        for function_name, dependencies in self.function_call_dependency_mapping.items():
            # We need to check if they are present in self.function_def to avoid built-in functions
            all_dependencies = {
                dep
                for dep in find_all_dependencies(self.function_call_dependency_mapping, start_entity=function_name)
                if dep in self.function_def.keys()
            }
            self.function_call_recursive_dependency_mapping[function_name] = all_dependencies

        # assign all nodes
        self.global_nodes = {**self.assignments, **self.classes, **self.function_def}
        # now sort the class dependency_mapping based on the position of the nodes
        self.class_start_line = {}
        for id, node in self.global_nodes.items():
            self.class_start_line[id] = self.get_metadata(cst.metadata.PositionProvider, node).start.line

        # If we are not only creating the function mapping, create the class dependencies and augment them with function recursive deps
        if not self.only_for_function_mapping:
            # Create the dependency mapping for classes now that all potentials classes, functiosn, and assignments have been defined
            for class_name, class_node in self.classes.items():
                self.class_dependency_mapping[class_name] = ClassDependenciesFinder.dependencies_for_node(
                    class_node, set(self.global_nodes.keys())
                )

            # Recursively add all functions dependencies to the class dependencies (the class cannot be defined without all
            # the needed functions -> they are considered 1st level dependencies)
            for class_name, dependencies in self.class_dependency_mapping.items():
                self.class_dependency_mapping[class_name] = self.augment_dependencies_with_functions(dependencies)

    def augment_dependencies_with_functions(self, dependencies: set) -> set:
        """For a set of `dependencies`, augment them by adding all potential functions which are dependencies of
        the functions present in the `dependencies`.
        """
        new_dependencies = dependencies.copy()
        # Go through the set of dependencies
        for dep in tuple(dependencies):
            if dep in self.function_call_recursive_dependency_mapping.keys():
                new_dependencies.update(self.function_call_recursive_dependency_mapping[dep])
        return new_dependencies


class ReplaceNameTransformer(m.MatcherDecoratableTransformer):
    """A transformer that replaces `old_name` with `new_name` in comments, string and any references.
    It should take into account name like `MyNewModel`, or `my_new_model`. Without using the AUTO_MAPPING.
    Supported renaming patterns:
        - llama -> my_new_model     and     my_new_model    -> llama
        - Llama -> MyNewModel       and     MyNewModel      -> Llama
        - LLAMA -> MY_NEW_MODEL     and     MY_NEW_MODEL    -> LLAMA
        - LLaMa -> MyNewModel       abd     MyNewModel      -> Llama
    """

    def __init__(
        self,
        old_name,
        new_name,
        given_old_name=None,
        given_new_name=None,
        old_class_name: str = None,
        new_class_name: str = None,
    ):
        super().__init__()
        self.old_name = old_name
        self.new_name = new_name
        self.default_name = "".join(x.title() for x in new_name.split("_"))
        if self.new_name in CONFIG_MAPPING_NAMES:
            self.default_name = CONFIG_MAPPING_NAMES[self.new_name].replace(
                "Config", ""
            )  # the best source of truth for class names. Could also just use the ones de
        self.patterns = {
            old_name: new_name,
            old_name.upper(): new_name.upper(),
            "".join(x.title() for x in old_name.split("_")): self.default_name,
        }
        if given_old_name is not None and given_new_name is not None and given_old_name not in self.patterns:
            self.patterns[given_old_name] = given_new_name
        if self.old_name in CONFIG_MAPPING_NAMES:
            self.default_old_name = CONFIG_MAPPING_NAMES[self.old_name].replace("Config", "")
            if self.default_old_name.isupper():
                self.default_old_name = self.default_old_name.capitalize()
        if new_class_name is not None and old_class_name is not None and old_class_name not in self.patterns:
            # In last recourse, when the suffix of the new class is not the same as the old class,
            # and if the old and new classes start with the default name, we keep the default class name
            # and replace the old suffix with the new one.
            # Useful when we have a class like `ColPaliForRetrieval` inheriting from `PaliGemmaForConditionalGeneration`
            # where a model extends another model, but is used for a different task.
            if old_class_name.startswith(self.default_old_name) and new_class_name.startswith(self.default_name):
                self.patterns[old_class_name[len(self.default_old_name) :]] = new_class_name[len(self.default_name) :]

    def preserve_case_replace(self, text):
        # Create a regex pattern to match all variations
        regex_pattern = "|".join(re.escape(key) for key in self.patterns.keys())
        compiled_regex = re.compile(regex_pattern, re.IGNORECASE)

        def replace(match):
            word = match.group(0)
            result = self.patterns.get(word, self.default_name)
            return result

        return compiled_regex.sub(replace, text)

    def convert_to_camelcase(self, text):
        # Regex pattern to match consecutive uppercase letters and lowercase the first set
        result = re.sub(
            rf"^({self.old_name})(?=[a-z]+)", lambda m: self.default_old_name, text, flags=re.IGNORECASE, count=1
        )
        return result

    @m.leave(m.Name() | m.SimpleString() | m.Comment())
    def replace_name(self, original_node, updated_node):
        if re.findall(r"# Copied from", updated_node.value):
            return cst.RemoveFromParent()
        update = self.preserve_case_replace(updated_node.value)
        return updated_node.with_changes(value=update)

    def leave_ClassDef(self, original_node, updated_node):
        return updated_node.with_changes(name=cst.Name(self.convert_to_camelcase(updated_node.name.value)))


def find_classes_in_file(
    module: cst.Module,
    old_id="llama",
    new_id="gemma",
    given_old_name=None,
    given_new_name=None,
    old_class_name=None,
    new_class_name=None,
):
    """Helper function to rename and then parse a source file using the ClassFinder"""
    transformer = ReplaceNameTransformer(
        old_id,
        new_id,
        given_old_name=given_old_name,
        given_new_name=given_new_name,
        old_class_name=old_class_name,
        new_class_name=new_class_name,
    )
    new_module = module.visit(transformer)

    wrapper = MetadataWrapper(new_module)

    class_finder = ClassFinder(new_module)
    wrapper.visit(class_finder)
    return class_finder


DOCSTRING_NODE = m.SimpleStatementLine(
    body=[
        m.Expr(
            value=m.SimpleString(
                # match anything between """ """
                value=m.MatchIfTrue(lambda value: re.search(r"\"\"\"[\s\S]*\"\"\"", value) is not None)
            )
        )
    ]
)


def SUPER_CALL_NODE(func_name):
    return m.Call(func=m.Attribute(value=m.Call(func=m.Name("super")), attr=m.Name(func_name)))


def is_call_to_super(node, func_name):
    return m.matches(
        node, m.SimpleStatementLine(body=[m.Return(SUPER_CALL_NODE(func_name)) | m.Expr(SUPER_CALL_NODE(func_name))])
    )


# Transformer class to replace ClassB.call_to_method and ClassB().call_to_method with super().call_to_method
class ReplaceMethodCallTransformer(cst.CSTTransformer):
    def __init__(self, all_bases: Set[str]):
        self.all_bases = all_bases

    def leave_Attribute(self, original_node: cst.Attribute, updated_node: cst.Attribute) -> cst.CSTNode:
        # Handle ClassB.call_to_method
        if (
            isinstance(original_node.value, cst.Name)
            and original_node.value.value in self.all_bases
            and isinstance(original_node.attr, cst.Name)
        ):
            # Replace with super().call_to_method
            return updated_node.with_changes(
                value=cst.Call(cst.Name("super")),
            )
        # Handle ClassB().call_to_method
        elif (
            isinstance(original_node.value, cst.Call)
            and isinstance(original_node.value.func, cst.Name)
            and original_node.value.func.value in self.all_bases
            and isinstance(original_node.attr, cst.Name)
        ):
            # Replace with super().call_to_method
            return updated_node.with_changes(func=cst.Attribute(value=cst.Call(func=cst.Name("super"))))
        return updated_node

    def leave_Call(self, original_node: cst.Call, updated_node: cst.Call) -> cst.CSTNode:
        # Check if the function being called is of the form ClassB().func_a or ClassB.func_a
        if isinstance(original_node.func, cst.Attribute) and (
            # Match ClassB().func_a(...)
            (
                isinstance(original_node.func.value, cst.Call)
                and isinstance(original_node.func.value.func, cst.Name)
                and original_node.func.value.func.value in self.all_bases
            )
            or
            # Match ClassB.func_a(...)
            (isinstance(original_node.func.value, cst.Name) and original_node.func.value.value in self.all_bases)
        ):
            # Check if the first argument is 'self', and remove it
            if len(original_node.args) > 0 and m.matches(original_node.args[0].value, m.Name("self")):
                # Create the new argument list without 'self'
                new_args = updated_node.args[1:]
            else:
                new_args = updated_node.args

            return updated_node.with_changes(args=new_args)
        return updated_node


def get_docstring_indent(docstring):
    # Match the first line after the opening triple quotes
    match = re.search(r'(?:"""|\'\'\'|```)\n(\s+)', docstring)
    if match:
        # Return the indentation spaces captured
        return len(match.group(1))
    return 0


def merge_docstrings(original_docstring, updated_docstring):
    # indent_level = get_docstring_indent(updated_docstring)
    original_level = get_docstring_indent(original_docstring)
    if not re.findall(r"\n\s*Args:\n", updated_docstring):
        # Split the docstring at the example section, assuming `"""` is used to define the docstring
        parts = original_docstring.split("```")
        if "```" in updated_docstring and len(parts) > 1:
            updated_docstring = updated_docstring.lstrip('r"')
            new_parts = updated_docstring.split("```")
            if len(new_parts) != 3:
                raise ValueError("There should only be one example, and it should have opening and closing '```'")
            parts[1] = new_parts[1]
            updated_docstring = "".join(
                [
                    parts[0].rstrip(" \n") + new_parts[0],
                    f"\n{original_level*' '}```",
                    parts[1],
                    "```",
                    parts[2],
                ]
            )
        elif updated_docstring not in original_docstring:
            # add tabulation if we are at the lowest level.
            if re.search(r"\n\s*.*\(.*\)\:\n\s*\w", updated_docstring):
                updated_docstring = updated_docstring.replace("\n    ", "\n        ")
            updated_docstring = original_docstring.rstrip('"') + "\n" + updated_docstring.lstrip('r"\n')
    return updated_docstring


class SuperTransformer(cst.CSTTransformer):
    METADATA_DEPENDENCIES = (ParentNodeProvider,)

    def __init__(self, python_module: cst.Module, original_methods, updated_methods, class_name="", all_bases=None):
        self.python_module = python_module
        self.original_methods = original_methods
        self.updated_methods = updated_methods
        self.all_assign_target = {}
        self.deleted_targets = {}  # child node can delete some arguments
        self.class_name = class_name
        self.all_bases = all_bases or []
        self.transformer = ReplaceMethodCallTransformer(set(self.all_bases))

    def update_body(self, existing_body, new_statements):
        """
        Helper method to update the body by removing duplicates before adding new statements.
        `existing_body` is the body of the original method, the parent class
        `new_statements` are the additional statements
        """
        deduplicated_new_body = []
        existing_nodes = set()
        for node in new_statements:
            if m.matches(node, m.SimpleStatementLine(body=[m.Assign()])):
                target = self.python_module.code_for_node(node.body[0].targets[0].target)
                self.all_assign_target[target] = node
            if m.matches(node, m.SimpleStatementLine(body=[m.Del()])):
                target = self.python_module.code_for_node(node.body[0].target)
                self.deleted_targets[target] = node

        for stmt in existing_body:
            if m.matches(stmt, m.SimpleStatementLine(body=[m.Assign()])):
                target = self.python_module.code_for_node(stmt.body[0].targets[0].target)
                if target in self.deleted_targets:
                    logger.warning(f"Deleted the assign for {target}")
                    continue
                if target in self.all_assign_target:
                    stmt = self.all_assign_target[target]
            # Skip the docstring (will be added later on, at the beginning)
            elif m.matches(stmt, DOCSTRING_NODE):
                continue
            comment_less_code = re.sub(r"#.*", "", self.python_module.code_for_node(stmt)).strip()
            comment_less_code = re.sub(r"\ *\n", "\n", comment_less_code).strip()
            deduplicated_new_body.append(stmt)
            existing_nodes.add(comment_less_code)

        for node in new_statements:
            code = self.python_module.code_for_node(node)
            comment_less_code = re.sub(r"#.*", "", code).strip()
            comment_less_code = re.sub(r"\ *\n", "\n", comment_less_code).strip()
            if node not in deduplicated_new_body and comment_less_code not in existing_nodes:
                if not m.matches(node, m.SimpleStatementLine(body=[m.Del()])):
                    deduplicated_new_body.append(node)
                    existing_nodes.add(comment_less_code)

        # Fix the post_init() that has to be last
        for i, node in enumerate(deduplicated_new_body):
            code = self.python_module.code_for_node(node)
            comment_less_code = re.sub(r"#.*", "", code).strip()
            comment_less_code = re.sub(r"\ *\n", "\n", comment_less_code).strip()
            if "self.post_init(" in comment_less_code and i < len(deduplicated_new_body) - 1:
                # Remove it and add it again at the end
                deduplicated_new_body.pop(i)
                deduplicated_new_body.append(node)
                break

        return deduplicated_new_body

    def _fix_init_location(self, new_body):
        """Fix the location of the super()__init__ in the new body, if we had new statements before it."""
        start_index = 0
        for i, node in enumerate(new_body):
            if m.matches(node, DOCSTRING_NODE) and i == start_index:
                start_index += 1
                continue
            code = self.python_module.code_for_node(node)
            comment_less_code = re.sub(r"#.*", "", code).strip()
            comment_less_code = re.sub(r"\ *\n", "\n", comment_less_code).strip()
            if "super().__init__" in comment_less_code and i > start_index:
                # Remove it and add it again at the top after the docstrings
                node = new_body.pop(i)
                new_body = new_body[:start_index] + [node] + new_body[start_index:]
                break
        return new_body

    def replace_super_calls(self, node: cst.IndentedBlock, func_name: str) -> cst.CSTNode:
        """Updates the body of the input `node`'s `func_name` function by replacing calls
        to super().func_name() with the source code of the parent class' `func_name`.
        It keeps everything that is defined before `super().func_name()`.
        """
        self.has_docstring = False
        parent_has_docstring = False
        if func_name in self.original_methods:
            parent_has_docstring = m.matches(self.original_methods[func_name].body.body[0], DOCSTRING_NODE)
        new_body = []
        has_super_call = False

        for i, expr in enumerate(node.body):
            if is_call_to_super(expr, func_name):
                has_super_call = True
                new_body.extend(self.update_body(self.original_methods[func_name].body.body, node.body[i + 1 :]))
                new_body = self._fix_init_location(new_body)
            else:
                expr = expr.visit(self.transformer)
            if m.matches(expr, DOCSTRING_NODE):
                self.has_docstring = True
                if parent_has_docstring:  # actually here we ought to de-duplicate?
                    original_docstring = self.original_methods[func_name].body.body[0].body[0].value.value
                    updated_docstring = expr.body[0].value.value
                    merged_doc = merge_docstrings(original_docstring, updated_docstring)
                    new_node = [expr.with_changes(body=[cst.Expr(value=cst.SimpleString(value=merged_doc))])]
                else:
                    new_node = [expr]
                new_body.extend(new_node)
            elif not m.matches(expr, m.SimpleStatementLine(body=[m.Del()])) and not has_super_call:
                new_body.append(expr)
        if not self.has_docstring and parent_has_docstring:
            new_body = [self.original_methods[func_name].body.body[0]] + new_body
        return node.with_changes(body=new_body)

    def leave_FunctionDef(self, original_node: cst.Call, updated_node: cst.Call) -> cst.CSTNode:
        if updated_node.name.value in self.updated_methods:
            name = updated_node.name.value
            new_body = self.replace_super_calls(updated_node.body, name)
            return updated_node.with_changes(body=new_body, params=updated_node.params)
        return updated_node

    def leave_Return(self, original_node: cst.Return, updated_node: cst.Return) -> cst.CSTNode:
        """ "When a return statement is reached, it is replaced with the unrolled super code"""
        if m.matches(updated_node.value, m.Call(func=m.Attribute(attr=m.Name("super")))):
            func_def = self.get_metadata(ParentNodeProvider, original_node)
            if m.matched(func_def, m.FunctionDef()) and func_def.name.value in self.original_methods:
                updated_return_value = updated_node.value.with_changes(
                    args=[
                        cst.Arg(
                            value=cst.Call(func=cst.Name("super"), args=[cst.Arg(value=cst.Name(func_def.name.value))])
                        )
                    ]
                )
                return updated_node.with_changes(value=updated_return_value)
        return updated_node


def replace_call_to_super(
    class_finder: ClassFinder, updated_node: cst.ClassDef, class_name: str, all_bases: List[str]
):
    """
    Given the `class_name`, the `updated_node`'s call to super are unpacked.

                    |    ```python                          |               |    ```python
                    |    class GemmaModel(LlamaModel):      |               |       class GemmaModel(nn.Module):
                    |        def __init__(self):            |               |           def __init__(self):
    Going from:     |            super().__init__()         |       to:     |               super().__init__(config)
                    |            self.dropout = 0.2         |               |               self.dropout = 0.2
                    |     ```                               |               |               self.padding_idx = config.pad_token_id
                                                                            |               self.vocab_size = config.vocab_size
                                                                            |               self.embed_tokens = nn.Embedding(config.vocab_size, config.hidden_size, self.padding_idx)
                                                                            |               self.layers = nn.ModuleList(
                                                                            |                   [LlamaDecoderLayer(config, layer_idx) for layer_idx in range(config.num_hidden_layers)]
                                                                            |               )
                                                                            |               self.norm = LlamaRMSNorm(config.hidden_size, eps=config.rms_norm_eps)
                                                                            |               self.gradient_checkpointing = False
                                                                            |               # Initialize weights and apply final processing
                                                                            |               self.post_init()
                                                                            |     ```
    """
    original_node = class_finder.classes[class_name]
    original_methods = {
        f.name.value if hasattr(f, "name") else class_finder.python_module.code_for_node(f): f
        for f in original_node.body.body
    }
    updated_methods = {
        f.name.value if hasattr(f, "name") else class_finder.python_module.code_for_node(f): f
        for f in updated_node.body.body
    }
    end_meth = []

    assign_targets = {}
    docstring_node = []
    # Iterate directly from node.body as there can be property/setters with same names which are overwritten when we use a dict
    for func in original_node.body.body:
        name = func.name.value if hasattr(func, "name") else class_finder.python_module.code_for_node(func)
        if m.matches(func, m.FunctionDef()) and name in updated_methods and updated_methods[name] is not None:
            new_params = updated_methods[name].params
            # Replace the method in the replacement class, preserving decorators
            kwarg_name = getattr(updated_methods[name].params, "star_kwarg", None)
            if kwarg_name and kwarg_name.name.value == "super_kwargs":
                parent_params = {k.name.value: k for k in func.params.params}
                parent_params.update({k.name.value: k for k in new_params.params[1:]})
                new_params = new_params.with_changes(
                    params=list(parent_params.values()), star_kwarg=func.params.star_kwarg
                )
            # Keep decorators in `modular_xxx.py` if any, else original decorators
            new_decorators = (
                updated_methods[name].decorators if len(updated_methods[name].decorators) > 0 else func.decorators
            )
            if not re.match(
                r"\ndef .*\(.*\):\n    raise.*Error\(.*",
                class_finder.python_module.code_for_node(updated_methods[name]),
            ):
                func = func.with_changes(body=updated_methods[name].body, params=new_params, decorators=new_decorators)
            else:
                continue

        if m.matches(func, m.SimpleStatementLine(body=[m.Assign()])):
            target = class_finder.python_module.code_for_node(func.body[0].targets[0])
            assign_targets[target] = func
        elif m.matches(func, m.SimpleStatementLine(body=[m.AnnAssign()])):
            target = class_finder.python_module.code_for_node(func.body[0].target)
            assign_targets[target] = func
        elif m.matches(func, DOCSTRING_NODE):
            docstring_node = [func]
        else:
            end_meth.append(func)

    # Port new methods that are defined only in modular-file and append at the end
    for func in updated_node.body.body:
        name = func.name.value if hasattr(func, "name") else class_finder.python_module.code_for_node(func)
        if m.matches(func, DOCSTRING_NODE):  # This processes the docstring of the class!
            # Extract the original docstring
            updated_docstring = func.body[0].value.value
            original_docstring = docstring_node[0].body[0].value.value
            merged_doc = merge_docstrings(original_docstring, updated_docstring)
            # Update the docstring in the original function
            docstring_node = [
                docstring_node[0].with_changes(body=[cst.Expr(value=cst.SimpleString(value=merged_doc))])
            ]
        if name not in original_methods and func is not None and isinstance(func, cst.FunctionDef):
            end_meth.append(func)
        if m.matches(func, m.SimpleStatementLine(body=[m.Assign()])):
            # TODO we only use single assign might cause issues
            target = class_finder.python_module.code_for_node(func.body[0].targets[0])
            assign_targets[target] = func
        if m.matches(func, m.SimpleStatementLine(body=[m.AnnAssign()])):
            target = class_finder.python_module.code_for_node(func.body[0].target)
            assign_targets[target] = func
    end_meth = docstring_node + list(assign_targets.values()) + end_meth

    result_node = original_node.with_changes(body=cst.IndentedBlock(body=end_meth))
    temp_module = cst.Module(body=[result_node])
    new_module = MetadataWrapper(temp_module)
    new_replacement_class = new_module.visit(
        SuperTransformer(temp_module, original_methods, updated_methods, class_name, all_bases)
    )
    new_replacement_body = new_replacement_class.body[0].body  # get the indented block

    return original_node.with_changes(body=new_replacement_body)


TYPE_TO_FILE_TYPE = {
    "Config": "configuration",
    "Tokenizer": "tokenization",
    "Processor": "processing",
    "ImageProcessor": "image_processing",
    "FeatureExtractor": "feature_extractor",
}


def get_new_part(class_name, base_class):
    """
    When `MyClassNameAttention` inherits from `MistralAttention`, we need
    to process the name to properly find dependencies.

    Here we take what is the same (Attention) and what is different
    when finding the dependencies.
    """
    common_suffix_len = 0
    for i in range(1, min(len(class_name), len(base_class)) + 1):
        if class_name[-i] == base_class[-i]:
            common_suffix_len += 1
        else:
            break

    if common_suffix_len > 0:
        new_part = class_name[:-common_suffix_len]
    else:
        new_part = class_name

    # Convert the remaining new part to snake_case
    snake_case = re.sub(r"(?<!^)(?=[A-Z])", "_", new_part).lower()
    return snake_case


class PostModularConverterCleaner(CSTTransformer):
    """Allow simple cleaning after conversion. Remove top-level functions/classes/assignments without any calls (they may arise due
    to dependency mapping, even if code parts with those functions/classes/assignments were overwritten)"""

    METADATA_DEPENDENCIES = (ParentNodeProvider,)

    def __init__(self):
        super().__init__()
        self.top_level_assignments = {}
        self.all_used_assignments = set()

    def visit_SimpleStatementLine(self, node):
        parent_node = self.get_metadata(cst.metadata.ParentNodeProvider, node)
        simple_top_level_assign_structure = m.SimpleStatementLine(
            body=[m.Assign(targets=[m.AssignTarget(target=m.Name())])]
        )
        if m.matches(parent_node, m.Module()) and m.matches(node, simple_top_level_assign_structure):
            self.top_level_assignments[node.body[0].targets[0].target.value] = node

    def visit_Name(self, node: cst.Name):
        """This is used to find any mention of a top-level function, class or assignment except its own definition.
        It will contain other names as well, but those will not be used. This is the most general way to do it
        since mentions may appear in a lot of different contexts (apart from simple Call to the function/class).
        e.g. Attention classes are only mentionned by their name in a dict assignment.
        """
        parent_node = self.get_metadata(cst.metadata.ParentNodeProvider, node)

        if not (m.matches(parent_node, m.AssignTarget()) and parent_node.target.value == node.value):
            self.all_used_assignments.add(node.value)

    def leave_Module(self, original_node: cst.Module, updated_node: cst.Module):
        # Find any class/function/assignment that was mistakenly added as part of the dependencies and remove it
        nodes_to_remove = [
            node for name, node in self.top_level_assignments.items() if name not in self.all_used_assignments
        ]
        new_body = [node_ for node_ in original_node.body if node_ not in nodes_to_remove]
        # Return a new module with the updated body
        return updated_node.with_changes(body=new_body)


class ModularConverterTransformer(CSTTransformer):
    METADATA_DEPENDENCIES = (ParentNodeProvider, ScopeProvider, PositionProvider)

    def __init__(self, python_module, new_name, given_old_name=None, given_new_name=None):
        super().__init__()
        self.model_name = (
            new_name  # name of the model being defined. Should be in the format of `llama` or `layout_xlm` our `phi3`
        )
        self.given_old_name = given_old_name
        self.given_new_name = given_new_name
        # fmt: off
        self.python_module = python_module       # we store the original module to use `code_for_node`
        self.transformers_imports = {}           # maps the imports name like "from transformers.models.xxx" to the parsed AST module
        self.imported_mapping = {}               # stores the name of the imported classes, with their source {"LlamaModel":"transformers.model.llama.modeling_llama"}
        self.visited_module = {}                 # modules visited like "transformers.models.llama.modeling_llama"
        self.visited_module_without_rename = {}  # same as above, but without renaming in the file
        self.inserted_deps = []                  # nodes inserted via super dependency
        self.all_imports = []                    # just stores all of the imports
        self.all_safe_imports = []               # stores the import under simple statements
        self.global_scope_index = 0
        # fmt: on
        self.files = {  # mapping for different component bodies
            "modeling": {},
            "configuration": {},
            "tokenization": {},
            "processing": {},
            "image_processing": {},
            "feature_extractor": {},
        }
        self.expected_body_keys = {
            file: {k for k, v in ASSIGNMENTS_TO_KEEP.items() if file in v} for file in self.files.keys()
        }
        self.match_patterns = "|".join(self.files.keys())
        self.all_definitions = {}
        self.class_to_file_type = {}
        self.current_class = None  # keep track of current top-level class during visit
        self.current_top_level_function = None  # keep track of current top-level function during visit
        # Mapping from top-level functions to classes using them
        self.function_call_class_mapping = defaultdict(lambda: set())
        # Mapping from top-level functions to other top-level functions dependencies
        self.function_call_dependency_mapping = defaultdict(lambda: set())
        # Keep track of top-level assignments
        self.top_level_assignments = {}

    def visit_ImportFrom(self, node: cst.ImportFrom) -> None:
        """When visiting imports from `transformers.models.xxx` we need to:
        1. Get the original source code
        2. Parse it into an AST Tree
        3. Add this import to `self.transformers_imports` as visited to not parse it twice
        """
        import_statement = self.python_module.code_for_node(node.module)
        if m.matches(node.module, m.Attribute()):
            for imported_ in node.names:
                _import = re.search(rf"(transformers\.models\..|..)*\.({self.match_patterns})_.*", import_statement)
                if _import:
                    source = _import.groups()[0]
                    if source == "modeling" and "Config" in self.python_module.code_for_node(imported_):
                        raise ValueError(
                            f"You are importing {self.python_module.code_for_node(imported_)} from the modeling file. Import from the `configuration_xxxx.py` file instead"
                        )
                    if "auto.modeling_auto" in import_statement:
                        continue
                    if import_statement not in self.transformers_imports:
                        if "models" not in import_statement:
                            import_statement = "models." + import_statement
                        if "transformers" not in import_statement:
                            import_statement = "transformers." + import_statement
                        source_code = get_module_source_from_name(import_statement)
                        tree = cst.parse_module(source_code)
                        self.transformers_imports[import_statement] = tree
                    imported_class = self.python_module.code_for_node(imported_.name)
                    self.imported_mapping[imported_class] = import_statement
        if m.matches(node.module, m.Name()):
            if "transformers" == import_statement:
                raise ValueError(
                    f"You are importing from {import_statement} directly using global imports. Import from the correct local path"
                )

    def leave_SimpleStatementLine(self, original_node, updated_node):
        parent_node = self.get_metadata(cst.metadata.ParentNodeProvider, original_node)
        simple_top_level_assign_structure = m.SimpleStatementLine(
            body=[m.Assign(targets=[m.AssignTarget(target=m.Name())])]
        )
        if m.matches(parent_node, m.Module()):
            if m.matches(updated_node, m.SimpleStatementLine(body=[m.Import()])):
                if updated_node not in self.all_imports:
                    self.all_imports.append(updated_node)
                return updated_node
            elif m.matches(updated_node, m.SimpleStatementLine(body=[m.ImportFrom()])):
                full_statement = self.python_module.code_for_node(updated_node.body[0].module)
                if (
                    # OR MATCH ..llama.modeling_llama
                    re.search(rf"(transformers\.models\..|..)*\.({self.match_patterns})_.*", full_statement)
                    and "auto.modeling_auto" not in full_statement
                ):
                    return cst.RemoveFromParent()
                if updated_node not in self.all_imports:
                    self.all_imports.append(updated_node)
                return updated_node
            elif m.matches(original_node, simple_top_level_assign_structure):
                assigned_variable = original_node.body[0].targets[0].target.value
                # Special case treated outside this block
                if assigned_variable == "__all__":
                    return updated_node
                # We immediately write the node
                if assigned_variable in ASSIGNMENTS_TO_KEEP.keys():
                    files_ = ASSIGNMENTS_TO_KEEP[assigned_variable]
                    for file_ in files_:
                        self.files[file_][assigned_variable] = {
                            "node": original_node,
                            "insert_idx": self.global_scope_index,
                        }
                # We record the node to maybe add it later if not part of the dependencies
                else:
                    self.top_level_assignments[assigned_variable] = (original_node, self.global_scope_index)

            self.global_scope_index += 100
        return updated_node

    def _get_class_finder(self, super_file_name, model_name, class_name, super_class):
        """This helper methods tries different way to get the `class_finder`, based on several different renaming
        patterns.
        """
        visited_module = self.visited_module

        # Try the usual way
        if super_file_name not in visited_module:  # only extract classes once
            class_finder = find_classes_in_file(
                self.transformers_imports[super_file_name],
                model_name,
                self.model_name,
                self.given_old_name,
                self.given_new_name,
            )
            visited_module[super_file_name] = class_finder
        else:  # we are re-using the previously parsed data
            class_finder = visited_module[super_file_name]

        correctly_parsed = class_finder.class_dependency_mapping.get(class_name, None) is not None

        # so, maybe standard renaming did not work (the class name is different) - we try with another renaming pattern
        if not correctly_parsed:
            potential_given_name = get_new_part(class_name, super_class)
            class_finder = find_classes_in_file(
                self.transformers_imports[super_file_name],
                model_name,
                potential_given_name,
                self.model_name,
                potential_given_name,
            )
            visited_module[super_file_name] = class_finder
            correctly_parsed = class_finder.class_dependency_mapping.get(class_name, None) is not None

        # last recourse, if the suffix of the new class is different from the one of the super class,
        # e.g. MyNewClassForSegmentation extends MyOldClassForObjectDetection we try with another renaming pattern
        if not correctly_parsed:
            class_finder = find_classes_in_file(
                self.transformers_imports[super_file_name],
                model_name,
                self.model_name,
                self.given_old_name,
                self.given_new_name,
                super_class,
                class_name,
            )
            visited_module[super_file_name] = class_finder
            correctly_parsed = class_finder.class_dependency_mapping.get(class_name, None) is not None

        # If this is still the case, we did not find any good option
        if not correctly_parsed:
            raise ValueError(
                f"We were unable to find dependencies for {class_name} (based on inheriting from {super_class})"
                f"   Here are all the global dependencies that we found in you modular file: {list(class_finder.class_dependency_mapping.keys())}."
                f"   This usually means that the name of `{class_name}` does not match the pattern of `{super_class}`"
            )

        return class_finder

    def _get_class_finder_without_rename(self, file):
        """This helper function tries to get the class finder, and if not available create a new one, only for function
        dependencies purposes (thus without renaming).
        """
        if file in self.visited_module:
            class_finder = self.visited_module[file]
        elif file in self.visited_module_without_rename:
            class_finder = self.visited_module_without_rename[file]
        else:
            wrapper = MetadataWrapper(self.transformers_imports[file])
            class_finder = ClassFinder(self.transformers_imports[file], only_for_function_mapping=True)
            wrapper.visit(class_finder)
            self.visited_module_without_rename[file] = class_finder
        return class_finder

    def visit_ClassDef(self, node: cst.ClassDef):
        """Used to keep track of current class"""
        self.current_class = node.name.value

    def leave_ClassDef(self, original_node, updated_node):
        """
        1. Filter the `base` classes of this class
        If they are from `transformers.models.xx` then:
        - take the AST tree of the module it comes from and parse it with a `ClassFinder`.
        - rename all every instance of `old_name` (llama) to `new_name` (gemma)
        2. We insert the modules which the inherited base depends on. This has to be done in
        the order of the dependencies. If on is already in the new_body (because it's defined in the diff file)
        then we remove it from the new body to add it again in the correct order.
        3. Replace the calls to `super().xxxx` merging parent code
        """
        class_name = original_node.name.value
        bases = [k.value.value for k in original_node.bases if k.value.value in self.imported_mapping]
        if len(bases) > 1:
            raise ValueError(
                f"{class_name} was defined with more than 1 model-specific super class. This is unsupported. We found {*bases,}."
            )
        all_bases = [k.value.value for k in original_node.bases]
        self.global_scope_index += 100

        # We need to replace the class node with the super class node
        if len(bases) == 1:
            super_class = bases[0]
            if super_class not in self.imported_mapping:
                raise ImportError(
                    f"{super_class} was not imported using `from transformers.models.xxxxx.modeling_xxxx import {super_class}"
                )
            super_file_name = self.imported_mapping[super_class]  # we need to get the parsed tree
            model_name = re.search(r"models\.\w*?\.\w*?_(\S*)", super_file_name)
            if model_name:
                model_name = model_name.groups()[0]
            else:
                raise ValueError(
                    f"Tried parsing the name of the imported package from {super_file_name}, could not extract the model name"
                )

            # Find correct file where to write the class node
            file_type = re.search(r"models?\.\w*?\.(\w*?)_", super_file_name).groups()[0]
            file_to_update = self.files[file_type]

            # Get the class finder corresponding to the inherited class
            class_finder = self._get_class_finder(super_file_name, model_name, class_name, super_class)

            # Create the new class node
            updated_node = replace_call_to_super(class_finder, updated_node, class_name, all_bases)
            # Use decorators redefined in `modular_xxx.py` if any
            if len(original_node.decorators) > 0:
                updated_node = updated_node.with_changes(decorators=original_node.decorators)

            # The node was modified -> only look for all dependencies (recursively) of the new node
            new_node_dependencies = ClassDependenciesFinder.dependencies_for_new_node(updated_node, class_finder)
            all_dependencies_to_add = find_all_dependencies(
                dependency_mapping=class_finder.class_dependency_mapping,
                initial_dependencies=new_node_dependencies,
                initial_checked_dependencies=set(file_to_update.keys()),
            )
            # We can easily get the correct order of dependencies from the class_finder of the parent
            dependencies = {
                dep: (class_finder.class_start_line[dep], class_finder.global_nodes[dep])
                for dep in all_dependencies_to_add
            }

        # No super class, just check functions and assignments dependency in the imports from other model-specific files
        else:
            match_pattern = "|".join(TYPE_TO_FILE_TYPE.keys())
            match = re.search(rf"({match_pattern})$", class_name)
            if match:
                file_type = TYPE_TO_FILE_TYPE[match.group(1)]
            else:
                file_type = "modeling"
            file_to_update = self.files[file_type]

            # Find the node dependencies, without relying on a parent
            new_node_dependencies = ClassDependenciesFinder.dependencies_for_new_node_without_parents(updated_node)
            # Match the dependencies against the imports
            mutual_dependencies = new_node_dependencies & self.imported_mapping.keys()
            # Get the files where we matched imports and visit them to get all dependencies
            files_to_visit = {self.imported_mapping[dep] for dep in mutual_dependencies}
            dependencies = {}
            for i, file in enumerate(files_to_visit):
                # This class finder is only used to find function dependency graphs
                class_finder = self._get_class_finder_without_rename(file)
                all_dependencies_to_add = class_finder.augment_dependencies_with_functions(mutual_dependencies)
                # Here we can only know the relative order of dependencies within a single file -> add them in the file order
                dependencies.update(
                    {
                        dep: (class_finder.class_start_line[dep] + i * 100000, class_finder.global_nodes[dep])
                        for dep in all_dependencies_to_add
                        if dep not in file_to_update.keys()
                    }
                )

        # Write dependencies to file
        dependencies = sorted(dependencies.items(), key=lambda x: x[1][0], reverse=True)
        start_insert_idx = self.global_scope_index
        for dependency, (_, node) in dependencies:
            # we can write to the correct body, using the source of the parent class
            node = self.all_definitions.pop(dependency, node)
            start_insert_idx -= 1
            file_to_update[dependency] = {"insert_idx": start_insert_idx, "node": node}

        # Write the class node to file
        self.class_to_file_type[class_name] = file_type
        file_to_update[class_name] = {"insert_idx": self.global_scope_index, "node": updated_node}

        self.current_class = None
        return updated_node

    def visit_FunctionDef(self, node):
        parent_node = self.get_metadata(cst.metadata.ParentNodeProvider, node)
        if m.matches(parent_node, m.Module()):
            self.current_top_level_function = node.name.value

    def leave_FunctionDef(self, original_node, node):
        parent_node = self.get_metadata(cst.metadata.ParentNodeProvider, original_node)
        if m.matches(parent_node, m.Module()):
            self.all_definitions[node.name.value] = node
            self.current_top_level_function = None
        return node

    def visit_Assign(self, node: cst.Assign) -> None:
        # Check if the assignment target is '__all__'
        if isinstance(node.targets[0].target, cst.Name) and node.targets[0].target.value == "__all__":
            if isinstance(node.value, cst.List):
                # Extract the elements from the list
                all_all_to_add = defaultdict(list)
                for elt in node.value.elements:
                    if isinstance(elt.value, cst.SimpleString):
                        # Remove quotes and add the string to the elements list
                        class_name = elt.value.value
                        file = self.class_to_file_type[
                            elt.value.evaluated_value
                        ]  # evaluated value give the content of the string
                        all_all_to_add[file] += [class_name]
                for f_type, new_alls in all_all_to_add.items():
                    updated_node = node.with_changes(
                        value=cst.List(elements=[cst.Element(value=cst.SimpleString(value=k)) for k in new_alls])
                    )
                    self.files[f_type][class_name] = {
                        "insert_idx": self.global_scope_index + 100,
                        "node": updated_node,
                    }

    def leave_If(self, original_node, node):
        parent_node = self.get_metadata(cst.metadata.ParentNodeProvider, original_node)
        if m.matches(parent_node, m.Module()):
            full_statement = self.python_module.code_for_node(original_node.test)
            if re.search(r"[\s\S]*is_.*available", full_statement):
                self.all_safe_imports.append(node)
            elif full_statement not in self.all_imports:
                logger.warning(f"one import is protected with `if`. Hard guess where it's used {full_statement}")
        return node

    def visit_Call(self, node: cst.Call):
        """This is used to create a mapping from functions to class calling them, and from top-level functions to functions called inside them.
        Important note: we only rely on direct Call to the functions here, not indirect mentions (such as assigning a variable with the function,
        add calling the variable later). This should be enough as the `modular_xxx` and `modeling_xxx` structures should be as simple as possible.
        """
        # Only map function calls if we're inside a class (i.e., current_class is set)
        if self.current_class is not None:
            # Simple function calls such as foo()
            if isinstance(node.func, cst.Name):
                self.function_call_class_mapping[node.func.value].add(self.current_class)
        elif self.current_top_level_function is not None:
            # Simple function calls such as foo()
            if isinstance(node.func, cst.Name):
                self.function_call_dependency_mapping[self.current_top_level_function].add(node.func.value)

    def _insert_node_in_body(
        self, new_node, body: dict, new_body_key: str, body_insert_index: int, add_new_lines: int = 0
    ):
        """Insert the `new_node` to the`body`, with the `new_body_key`.
        The node is inserted with given `body_insert_index` (usually the index of an exising body element), and all nodes
        with same or larger index are remapped to keep the same relative order in the final body.
        Optionally, some new lines may be inserted before the given node.
        """
        # Reorder the elements
        for element in body.keys():
            if body[element]["insert_idx"] >= body_insert_index:
                body[element]["insert_idx"] += 1
        # Assign new element to body (after changing the count to avoid messing it)
        if add_new_lines > 0:
            # Wrap it inside a Module node to easily add the newlines
            new_node = cst.Module(body=add_new_lines * [cst.Newline()] + [new_node])
        body[new_body_key] = {"insert_idx": body_insert_index, "node": new_node}

    def _maybe_add_function_to_body(
        self,
        top_level_function: str,
        body: dict,
        function_node: cst.FunctionDef,
        matching_callers: Optional[set] = None,
        parent: Optional[str] = None,
    ) -> bool:
        """Check if the `top_level_function` should be added to the body (i.e. it is not already present, and `matching_callers`
        is not empy, or `parent`is provided). If it should be added, do it (in the correct location, just before its caller) and return
        `True`. Return `False` otherwise.
        """
        if matching_callers is None and parent is None:
            raise ValueError("Cannot add function if both the parent and the matching callers are None.")
        if matching_callers is None:
            matching_callers = {parent}
        if len(matching_callers) > 0 and top_level_function not in body.keys():
            # Add the function just before the first class using it
            new_idx = min([body[element]["insert_idx"] for element in matching_callers])
            self._insert_node_in_body(function_node, body, top_level_function, new_idx)
            return True
        return False

    def recursively_add_all_new_needed_functions_in_files(self):
        """For all top-level functions which were newly defined in the `modular_xxx.py`, check if they are used in a class in
        the different files, and add them to the file if it is the case (also recursively adding all other functions that
        may be needed in that function body)."""
        # At this point, `self.all_definitions` only contains newly defined top-level functions in the `modualr_xxx.py`
        for top_level_function, function_node in self.all_definitions.items():
            calling_entities = self.function_call_class_mapping[top_level_function]
            # The function may be needed in different files, we need to iterate on them
            for file, body in self.files.items():
                file_elements = set(body.keys())
                # If the intersection is not null, top_level_func must be added to file
                matching_callers = calling_entities & file_elements
                added = self._maybe_add_function_to_body(top_level_function, body, function_node, matching_callers)
                # If the function was added, we need to recursively add all its dependencies
                if added:
                    for dependency, parent in find_all_dependencies(
                        self.function_call_dependency_mapping, start_entity=top_level_function, return_parent=True
                    ):
                        if dependency in self.all_definitions:
                            self._maybe_add_function_to_body(
                                dependency, body, self.all_definitions[dependency], parent=parent
                            )

    def add_all_new_needed_assignments_in_files(self):
        """This adds all top-level assignments in the `modular_xxx.py` file in the created files, if not already present
        due to the dependencies.
        Since we cannot know in advance which file a top-level assignemnts in `modular_xxx.py` is supposed to
        be written in, we write it to all non-empty files. If it is not needed, it will be removed later with the
        `PostModularConverterCleaner()`.
        """
        for variable_name, (node, insert_idx) in self.top_level_assignments.items():
            # Since we cannot know in advance which file a top-level assignemnts in `modular_xxx.py` is supposed to
            # be written in, write it to all non-empty files. If it is not needed, it will be removed later
            for file, body in self.files.items():
                # Only write the variable to non-empty bodies
                if len(body) > 0 and body.keys() != self.expected_body_keys[file]:
                    if variable_name not in body.keys():
                        self._insert_node_in_body(node, body, variable_name, insert_idx)

    def leave_Module(self, original_node: cst.Module, node):
        imports = {self.python_module.code_for_node(k): k for k in self.all_imports}
        dependency_imports = {file_type: imports.copy() for file_type in self.files}
        for super_file_name, visiter in self.visited_module.items():
            file_type = re.search(r"models?\.\w*?\.(\w*?)_", super_file_name).groups()[0]
            dependency_imports[file_type].update(
                {self.python_module.code_for_node(k): k for k in visiter.imports.values()}
            )

        # Check if any new top-level function from the `modular_xxx.py` should be added to the different files
        # (if it is called in a class in the file, then it will be copy pasted from `modular.py` to that file).
        self.recursively_add_all_new_needed_functions_in_files()
        # Add all potentially missing assignments
        self.add_all_new_needed_assignments_in_files()

        for file, body in self.files.items():
            new_body = [k[1]["node"] for k in sorted(body.items(), key=lambda x: x[1]["insert_idx"])]
            if len(new_body) > 0 and body.keys() != self.expected_body_keys[file]:
                if file in dependency_imports.keys():
                    new_body = list(dependency_imports[file].values()) + new_body
                new_module = cst.Module(body=[*new_body], header=node.header)
                # Final cleanup
                new_module = MetadataWrapper(new_module).visit(PostModularConverterCleaner())
                self.files[file] = new_module
            # In this case, only the nodes corresponding to ASSIGNMENTS_TO_KEEP are present -> we don't want to create the file
            else:
                self.files[file] = {}
        return node


def convert_modular_file(modular_file, old_model_name=None, new_model_name=None, cst_transformers=None):
    pattern = re.search(r"modular_(.*)(?=\.py$)", modular_file)
    output = {}
    if pattern is not None:
        model_name = pattern.groups()[0]
        # Parse the Python file
        with open(modular_file, "r") as file:
            code = file.read()
        module = cst.parse_module(code)
        wrapper = MetadataWrapper(module)
        if cst_transformers is None:
            cst_transformers = ModularConverterTransformer(module, model_name, old_model_name, new_model_name)
        wrapper.visit(cst_transformers)
        for file, node in cst_transformers.files.items():
            if node != {}:
                # Get relative path starting from src/transformers/
                relative_path = re.search(
                    rf"(src{os.sep}transformers{os.sep}.*|examples{os.sep}.*)", os.path.abspath(modular_file)
                ).group(1)

                header = AUTO_GENERATED_MESSAGE.format(
                    relative_path=relative_path, short_name=os.path.basename(relative_path)
                )
                ruffed_code = run_ruff(header + node.code, True)
                formatted_code = run_ruff(ruffed_code, False)
                output[file] = [formatted_code, ruffed_code]
        return output
    else:
        print(f"modular pattern not found in {modular_file}, exiting")
        return {}


def save_modeling_file(modular_file, converted_file):
    for file_type in converted_file.keys():
        non_comment_lines = len(
            [line for line in converted_file[file_type][0].strip().split("\n") if not line.strip().startswith("#")]
        )
        if len(converted_file[file_type][0].strip()) > 0 and non_comment_lines > 0:
            with open(modular_file.replace("modular_", f"{file_type}_"), "w") as f:
                f.write(converted_file[file_type][0])
        else:
            non_comment_lines = len(
                [line for line in converted_file[file_type][0].strip().split("\n") if not line.strip().startswith("#")]
            )
            if len(converted_file[file_type][1].strip()) > 0 and non_comment_lines > 0:
                logger.warning("The modeling code contains errors, it's written without formatting")
                with open(modular_file.replace("modular_", f"{file_type}_"), "w") as f:
                    f.write(converted_file[file_type][1])


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--files_to_parse",
        default=["src/transformers/models/instructblipvideo/modular_instructblipvideo.py"],
        nargs="+",
        help="A list of `modular_xxxx` files that should be converted to single model file",
    )
    parser.add_argument(
        "--old_model_name",
        required=False,
        help="The name of the model from which the copying is done in CamelCase. If not provided is inferred from modular-file",
    )
    parser.add_argument(
        "--new_model_name",
        required=False,
        help="The name of the new model being added in CamelCase. If not provided is inferred from modular-file",
    )
    args = parser.parse_args()
    if args.files_to_parse == ["all"]:
        args.files_to_parse = glob.glob("src/transformers/models/**/modular_*.py", recursive=True)

    for file_name in find_priority_list(args.files_to_parse):
        print(f"Converting {file_name} to a single model single file format")
        module_path = file_name.replace("/", ".").replace(".py", "").replace("src.", "")
        converted_files = convert_modular_file(file_name, args.old_model_name, args.new_model_name)
        converter = save_modeling_file(file_name, converted_files)
